{
	var result = {
		errors: [],
		polygon: [],
		references: [],
		rgbs: []
	};

	function concat(v) {
		return v.join('');
	}
	function toNumber(v) {
		return Number(concat(v));
	}
	function toIndex(v) {
		return toNumber(v) - 1;
	}
	function arrayToObj(array) {
		var obj = {};
		array.forEach(function (entry) {
			for(var key in entry) {
				obj[key] = entry[key];
			}
		});
		return obj;
	}
}

content = comment? cmd* newline? {
	return result;
}

cmd = newline entry:(crr / version / ost / ifm / dtm / ced / cph / bsb / knp / knq / rgb / ref / ply / error / wppw / any) { return entry }

text = text:[^\r\n]* { return concat(text) }
inner_text = text:[^,\r\n]* { return concat(text) }
newline = '\r'? '\n'
indent = newline '    '
comma = ','
number = number:[\-0-9\.e+]+ { return toNumber(number) }
index = v:([1-9][0-9]*) { return toNumber(v) - 1 }
words = words:[a-zA-Z0-9 ]+ { return concat(words) }
sep = (comma / indent)*
color = r:number comma g:number comma b:number { return [r, g, b] }
date = d:number '/' m:number '/' y:number { return [d, m ,y] }

comment = '!' comment:text { result.comment = comment }

// CRR Definition
certificate_line = indent text:text { return text }
certificate = lines:certificate_line+ { return lines.join(' ') }
crr = 'CRR/CERTIFICATE OF AUTHENTICITY:' certificate:certificate {
	result.certificate = certificate
}

// Version definition
version = 'VER/' version:number { result.version = version }

// BSB definition
bsb = 'BSB/' entries:bsb_entry+ { result.bsb = arrayToObj(entries) }
bsb_entry = entry:(bsb_na / bsb_nu / bsb_ra / bsb_du) sep { return entry }
// RA=width,height - width and height of raster image data in pixels
bsb_ra = 'RA=' width:number comma height:number {
	return { width: width, height: height }
}
// NA=Name given to the BSB chart (can represent more than one .KAP)
bsb_na = 'NA=' name:inner_text? { return { name: name } }
// NU=Number of chart (especially when more than one chart is grouped or tiled together)
bsb_nu = 'NU=' index:inner_text? { return { index: index } }
// DU=Drawing Units in pixels/inch (same as DPI resolution) e.g. 50, 150, 175, 254, 300
bsb_du = 'DU=' dpi:number? { return { dpi: dpi } }

// KPN
knp = 'KNP/' entries:knp_entry+ { result.knp = arrayToObj(entries) }
knp_entry = entry:(knp_sc / knp_gd / knp_pr / knp_pp / knp_pi / knp_sp / knp_sk / knp_ta / knp_un / knp_sd / knp_dx / knp_dy) sep { return entry }
// SC=Scale e.g. 25000
knp_sc = 'SC=' sc:number? { return { scale: sc } }
// GD=Geodetic Datum e.g. NAD83, WGS84
knp_gd = 'GD=' gc:words? { return { datum: gc } }
// PR=Projection e.g. LAMBERT CONFORMAL CONIC, MERCATOR
knp_pr = 'PR=' pr:words? { return { projection: pr } }
// PP=Projection Parameter (value depends upon Projection) e.g. 135.0
knp_pp = 'PP=' pp:number? { return { projectionParameter: pp } }
// PI=? e.g. 0.0, 0.033333, 0.083333, 2.0
knp_pi = 'PI=' pi:number? { return { pi: pi } }
// SP=?
knp_sp = 'SP=' sp:words? { return { sp: sp } }
// SK=Skew angle? e.g. 0.0
knp_sk = 'SK=' sk:number? { return { skewAngle: sk } }
// TA=? e.g. 90
knp_ta = 'TA=' ta:number? { return { ta: ta } }
// UN=Units (for DX, DY and others) e.g. METRES, FATHOMS
knp_un= 'UN=' un:words? { return { units: un } }
// SD=Sounding Datum e.g. MEAN LOWER LOW WATER, HHWLT
knp_sd = 'SD=' sd:words? { return { sounding: sd } }
// DX=distance (approx.) covered by one pixel in X direction
knp_dx = 'DX=' dx:number? { return { dx: dx } }
// DY=distance (approx.) covered by one pixel in Y direction
knp_dy = 'DY=' dy:number? { return { dy: dy } }

// KNQ – Additional parameters - Optional
knq = 'KNQ/' entries:knq_entry+ { result.knq = arrayToObj(entries) }
knq_entry = entry:knq_x sep { return entry }
// P1=?,
// P2 - the same as KNP PP for Mercator and Transverse Mercator projection.
// P3= scale factor for Transverse Mercator; 1st standard parallel for lambert conic
// P4= 0 for Transverse Mercator; 2nd standard parallel for lambert conic
// P5= Central meridian for Transverse Mercator and lambert conic
// P6= origin of latitude for Transverse Mercator and lambert conic
// P7 = +x_0 for Transverse Mercator and lambert conic
// P8 = +y_0 for Transverse Mercator and lambert conic
// EC=?
// GD=?
// VC= ?
// SC=?
// PC=?. Set to TC for Transverse Mercator.
knq_x = key:([A-Z][A-Z0-9]) '=' value:inner_text? {
	var obj = {};
	obj[concat(key).toLowerCase()] = value;
	return obj;
}

// OST - Offset STrip image lines (number of image rows per entry in the index table) e.g. 1. Generated by imgkap.
ost = 'OST/' ost:number {
	result.offsetStrip = ost;
}

// IFM - Depth of the colormap (bits per pixel). BSB supports 1 through 7 (2 through 127 max colors). Or compression type? Generated by imgkap.
ifm = 'IFM/' ifm:number {
	result.colormapDepth = ifm;
}

// DTM – Datum shift parameters - Datum's northing and easting in floating point seconds to go between chart datum and WGS84 (omitted or 0,0 for WGS84 charts)
dtm = 'DTM/' x:number comma y:number {
	result.dtm = [x, y];
}

// CED – Chart edition parameters - optional
ced = 'CED/' entries:ced_entry+ {
	result.chartEdition = arrayToObj(entries);
}
ced_entry = entry:(ced_se / ced_re / ced_ed) sep { return entry }
// SE - Source edition / number of paper chart
ced_se = 'SE=' se:number? { return { source: se } }
// RE - Raster edition / number
ced_re = 'RE=' re:number? { return { raster: re } }
// ED - Chart edition date/number
ced_ed = 'ED=' ed:date? { return { chart: ed } }

// CPH – Phase shift value - optional
cph = 'CPH/' cph:number {
	result.phaseShift = cph;
}

// RGB - Entries in the raster colormap of the form index,red,green,blue (index 0 is not used in BSB)
rgb = 'RGB/' i:index comma color:color { 
	result.rgbs[i] = color;
}

// REF
ref = 'REF/' i:index comma x:number comma y:number comma lat:number comma lng:number { 
	result.references[i] = { x: x, y: y, lat:lat, lng: lng };
}

// PLY
ply = 'PLY/' i:index comma lat:number comma lng:number {
	result.polygon[i] = [lat, lng];
}

error = 'ERR/' i:index comma x:number comma y:number comma lat:number comma lng:number {
	result.errors[i] = { x: x, y:y, lat:lat, lng: lng};
}

wppw = key:('WPX' / 'WPY' / 'PWX' / 'PWY') '/' value:number values:wppw_entry+ { 
	result[key.toLowerCase()] = [value].concat(values);
}
wppw_entry = ((comma / indent) value:number) { return value }

subany = indent value:text { return value }
any = key:([A-Z][A-Z][A-Z]) '/' value:text values:subany* {
	result[concat(key).toLowerCase()] = value + ' ' + values.join(' ');
}